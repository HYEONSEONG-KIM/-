# 논리 데이터 베이스 설계

## 75.데이터베이스 설계
- 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 특정 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것
- 설계시 고려사항
     - 무결성 : 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함
     - 일관성 : 처음부터 끝까지 변함없이 일정해야 함
     - 회복 : 장애 발생시 장애 직전의 상태로 복구할 수 있어야함
     - 보안 : 불법적인 데이터의 노출이나 변경, 손실로 부터 보호할 수 있어야 함
     - 효율성 : 응답시간 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함
     - 데이터베이스 확장 : DB운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야함
- 설계 순서 : 요구 조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현
- 개념적 설계(정보 모델링, 개념화) : 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
    - 개념 스키마 모델링과 트랜잭션 모델링 병행 수행
    - E-R 다이어그램 작성
    - 독립적인 개념 스키마 설계
- 논리적 설계(데이터 모델링) : 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정
    - 논리적 구조의 데이터로 모델화
    - 개념 스키마를 평가 및 정제하고 서로 다른 논리적 스키마를 설계
    - 트랜잭션의 인터페이스 설계
    - 관계형 데이터베이스라면 테이블을 설계
- 물리적 설계(데이터 구조화) : 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정
    - DB파일의 저장 구조 및 액세스 경로 결정
    - 저장 레코드 형식, 순서, 접근 경로, 조회과 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사
- 구현 : 논리, 물리 단계에서 도출된 데이터 베이스 스키마를 파일로 생성하는 과정
    - DDL을 이용하여 스키마를 기술한 후 컴파일하여 빈 DB파일 생성
    - 트랜잭션 작성
    - DB접근을 위한 응용 프로그램 작성



## 76.데이터 모델의 개념
- 데이터 모델 : 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
    - 데이터, 데이터의 관계, 의미 및 일관성, 제약 조건 들을 기술하기 위한 개념적 도구들의 모임
    - 현실 세계를 DB에 표현하는 중간 과정, 데이터 구조(스키마)를 논리적으로 표현하기 위해 사용되는 지능적 도구
- 데이터 모델의 구성 요소
    - 개체(Entity) : 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 헌실 세계의 대상체(명사)
    - 속성(Attribute) : 데이터의 가장 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
    - 관계(Relationship) : 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미
- 개념적 데이터 모델 : 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
- 논리적 데이터 모델 : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
- 논리적 데이터 모델의 품질 검증 : 완성된 논리 모델이 기업에 적합한지를 확인하기 위해 품질을 검증하는 것
    - 개체 품질 검증 항목
    - 속성 품질 검증 항목
    - 관게 품질 검증 항목
    - 식별자 품질 검증 항목
    - 전반적인 품질 검증 항목
- 데이터 모델에 표시할 요소
    - 구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
    - 연산(Opertation) : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 DB를 조작하는 기본 도구
    - 제약 조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건


## 77.데이터 모델의 구성 요소 - 개체(entity)
- DB에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
- Entity 선정 방법
    - 업무 기술서 이용
    - 담당자와 인터뷰
    - 실제업무를 직접 견학
    - 장부와 전표 이용
    - 시스템의 산출물을 검토
    - 자료흐름도 이용시 자료저장소 이용
    - BRP(업무 프로세스 재설계)에 의해 업무를 재정의 할 경우 관련 개체 찾기
- 개체명 지정 방법
    - 해당 업무에서 사용하는 용어 지정
    - 약어사용 제한
    - 단수 명사
    - 유일성
    - 의미에 따라 이름 부여


## 78.데이터 모델의 구성 요소 - 속성(Attribute)
- DB를 구성하는 가장 작은 논리적 단위
- 속성의 수를 디그리(Degree) 또는 차수라고 함
- 속성의 종류
    - 속성 특성에 따른 분류
        - 기본 속성(Basic Attribute) : 업무 분석을 통해 정의한 속성
        - 설계 속성(Designed Attribute) : 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
        - 파생 속성(Derived Attribute) : 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성
    - 개체 구성 방식에 따른 분류
        - 기본키 속성(Primary Key Attribute) : 개체를 식별할 수 있는 속성
        - 외래키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성
        - 일반 속성 : 개체에 포함되어 있고, 외래키에 포함 되지 않은 속성
- 속성 후보 선정 원칙
    - 원시속성으로 판단되는 속성 후보는 버리지 않음
    - 소그룹별로 속성 후보군을 만들고 가장 근접한 개체에 할당
- 속성명 지정 원칭
    - 해당업무에 사용하는 용어 지정
    - 서술형으로 지정하지 않음
    - 약어 사용 제한
    - 개체명으로 불가
    - 유일하게 식별이 가능


## 79.데이터 모델의 구성 요소 - 관계(Relationship)
- 개체와 개체 사이의 논리적인 연결을 의미
- 관계의 형태 : 1:1, 1:N, N:M의 관계로 구성
- 관게의 종류
    - 종속 관계(Dependent Relationship) : 두 개체 사이의 주 종 관계를 표현한 것으로, 식별관계와 비식별 관계가 있음
    - 중복 관계(Redundant Relationship) : 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계
    - 재귀 관계(Recursive Relationdhip) : 개체가 자시 자신과 관계를 갖는 것으로, 순환관계 라고도 함
    - 배타 관계(Exclusive Relationship) : 개체가 둘 이상의 다른 개체의 합집합 또는 교집합 관계


## 80.식별자(Identifier)
- 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자로, 모든 개체는 한 개 이상의 식별자를 가져야 함
- 대표성 여부 : 주식별자/보조식별자
    - 주 식별자는 개체를 대표하는 유일한 식별자
    - 보조 식별자는 주 식별자를 대신하여 대체를 식별할 수 있는 속성
    - 둘 다 유일하게 식별해야 함
    - 주 식별자 -> 1개, 보조 식별자 -> 한 개 이상
        - 유일성 : 유일하게 구분
        - 최소성 : 유일성을 만족하는 최소 수가 되어야 함
        - 불변성 : 식별자는 변하지 않아야 함
        - 존재성 : 반드시 데이터 값 존재
- 스스로 생성 여부 : 내부 식별자/외부 식별자
    - 내부 식별자는 개체 내에서 스스로 만들어지는 식별자
    - 외부 식별자는 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용하는 식별자
- 단일 속성 여부 : 단일 식별자/복합 식별자
    - 단일 식별자는 주 식별자가 한 가지 속성으로만 구성된 식별자
    - 복합 식별자는 주 식별자가 두 개 이상의 속성으로 구성된 식별자
- 대체 여부 : 원조 식별자/대리 식별자
    - 원조 식별자는 업무에 의해 만들어지는 가공되지 않은 원래의 식별자로, 본질 식별자
    - 대리 식별자는 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자, 인조 식별자
    - 대리 식별자 조건
        - 최대한 범용적인 값 사용
        - 유일한 값을 만들기 위한 대리 식별자 사용
        - 하나의 대리 식별자 속성으로 대체할 수 없는 경우를 주의
        - 편의성과 단순성, 의미의 체계화를 위한 대리 식별자를 사용
        - 시스템적인 필요성에 의해 내부적으로만 사용하는 대리 식별자를 사용
- 후보 식별자 : 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성의 집합을 의미


## 81.E-R(개체-관계) 모델
- 데이터 모델의 가장 대표적인 것으로, 1976년 피터 첸에 의해 제안되고 기본적인 구성 요소가 정립
- E-R 다이어그램 : E-R 모델의 기본 아이디어를 시각적으로 표현하기 위한 그림으로, 실체 간의 관계는 물론 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 실체들을 표현
    - 개체 : 사각형
    - 관계 : 마름모
    - 속성 : 타원
    - 다중값 속성(복합 속성) : 이중 타원
    - 기본키 속성 : 밑줄 타원
    - 복합 속성 : 복수 타원
    - 관계 수: 대응수를 선위에 기술
    - 개체 타입과 속성 연결 : 선, 링크

## 82.관계형 데이터 모델
- 가장 널리 사용되는 데이터 모델로, 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 DB 구조
    - 파일 구조 처럼 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
    - 기본키와 외래키로 데이터 간의 관계 표현
    - 계층 모델과 망 모델의 복합한 구조를 단순화
    - 관계형 모델의 대표적 언어는 SQL
    - 관계 차수를 자유롭게 표현


## 83.관계형 데이터베이스 구조
- RDB를 구성하는 개체, 관계를 모두 릴레이션이라는 Table로 표현
- 간결하고 보기 편하며 다른 DB로의 변환이 용이하다는 장점이 있지만, 성능이 다소 떨어지는 단점
- Relation 구조 : 릴레이션은 데이터들을 표의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성
    - 튜플 : 행, row, 레코드(튜플의 수 카디널리티, 기수, 대응수)
    - 속성 : 가장 작은 논리적 단위, 데이터 필드, 열, column(속성의 수 디그리, 차수)
    - 도메인 : 하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합
- 릴레이션의 특징
    - 릴레이션에 포함된 튜플은 모두 다름
    - 튜플 사이에는 순서가 없음
    - 튜플의 작업을 시간에 따라 변함
    - 속성의 순서는 중요치 않음
    - 속성의 명칭을 유일하지만, 구성하는 값은 동일할 수 있음
    - 튜플을 유일하게 식별하기 위해 속성들의 부분 집합을 키로 설정
    - 속성은 원자값만을 저장


## 84.관계형 데이터베이스의 제약 조건 - 키(Key)
- 제약 조건 : DB에 저장되는 데이터의 정확성을 보장하기 위하여 키를 이용하여 입력되는 데이터에 제한을 주는 것으로 개체 무결성, 참조 무결성 제약 등이 해당
- 키(Key) : DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 의미
- 후보키(Candidate Key) : 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 의미
- 기본키(Primary Key) : 후보키 중에서 특별히 선정되 주키(Main Key)로 중복된 값을 가질 수 없음
- 대체키(Alternate Key) : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
- 슈퍼키(Super Key) : 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
- 외래키(Foreign key) : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

## 85.관계형 데이터베이스의 제약 조건 - 무결성
- DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미(데이터의 정확성을 보장하기 위해 부정확한 자료가 DB 내에 저장되는 것을 방지)
- 개체 무결설(Entity Integrity,실체 무결성) : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질수 없다는 규정
- 도메인 무결성(Domain Integrity,영역 무결성) : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- 참조 무결성(Referental Integrity) : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일 해야함, 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음
- 사용자 정의 무결성 : 속성 값들이 사용자가 정의한 제약조건에 만족해야 함
- 데이터 무결성 강화 : 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화
    - 애플리케이션 : 데이터 CUD시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가, 검사는 DB내에서 수행하기 어려우므로 애플리케이션 내에서 수행
    - 데이터베이스 트리거 : 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
    - 제약 조건 : 데이터베이스에 제약조건을 설정하여 무결성을 유지


## 86.관계대수 및 관계해석
- 관계대수 : 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절자적인 언어
    - 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공, 피연산자 결과 모두 릴레이션
    - 연산의 순서를 명시
    - 순수 관계 연산자 : Select, Project, Division
        - Select : 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산(수평 연산, 시그마 사용)
        - Project : 주어진 릴레이션 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산(수직 연산, 파이 사용)
        - Join : 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산(교차곱을 수행한후 select를 수행한것과 같음, 리본모양 사용)
        - Division : X ⊃ Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 대, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산(나누기 사용)
    - 일반 집합 연산자 : UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)
        - UNION : 두 릴레이션에 존재하는 튜플의 합집합, 중복되는 튜플 제거
        - INTERSECTION : 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
        - DIFFERENCE : 두 릴레이션에 존재하는 차집합
        - CARTESIAN PRODUCT : 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
- 관계해석(Relational Calculus) : 관계 데이터 모델의 제안자인 코드(E.F.Codd)가 수학의 Predicate Calculus에 기반을 두고 관계 데이터베이스를 위해 제안
    - 관계 데이터의 연산을 표현하는 방법
    - 비절차적 특성
    - 튜플 관계해석과 도메인 관계해석
    - 관계대수로 표현한 식은 관계해석으로 표현할 수 있음
    - 질의어로 표현


## 87.정규화(Normalization)
- 함수적 종속성 등의 종석성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정
    - 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
    - 1~5 정규형, 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어남
    - DB의 논리적 설계 단계에서 수행
    - 논리적 처리 밒 품질에 큰 영향
    - 일관성, 정확성, 단순성, 비중속석, 안정성을 보장
    - 유연한 데이터 구축이 가능하고 정확성이 높아지지만 조회성능이 저하
- 정규화의 목적
    - 데이터 구조의 안정성 및 무결성 유지
    - 어떠한 릴레이션이라도 DB 내에서 표현 가능
    - 효과적인 검색 알고리즘
    - 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화
    - 데이터 모형의 단순화
    - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임
    - 속성의 배열 상태 검증 가능
    - 개체와 속성의 누락 여부 확인 가능
    - 자료 검색과 추출의 효율성을 추구
- 이상(Anomaly)의 개념 및 종류 : 정규화를 거치지 않으면 DB 내에 데이터들이 불필요하게 중복되어 릴레이션 조작시 예기치 못한 곤란한 현상 발생, 이를 이상
    - 삽입이상(Insertion Anomaly) : 삽입 시 의도와는 상관없는 값이 삽입
    - 삭제 이상(Deletion Anomaly) : 삭제 시 의도와는 상관없는 값이 삭제 연쇄
    - 갱신 이상(Update Anomaly) : 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 모순이 생김
- 정규화 과정
    - 1NF : 모든 도메인이 원자값(한 튜플에서 같은 열에 중복 값이 없어야 함)
    - 2NF : 부분적 함수 종속(불완전 함수 종속) 제거, 나머지 속성이 기본키에 종속
    - 3NF : 이행적 함수 종속 제거(무손실 조인 or 종속성 보존을 저해하지 않고도 항상 3NF 설계를 얻을 수 있음)
    - BCNF(Boyce-Codd) : 결정자 이면서 후보키가 아닌 것 제거, 강한 3 정규형, 모든 BCNF가 종속성을 보존하는 것은 아님
    - 4NF : 다치 종속 제거
    - 5NF : 조인 종속성 이용
    - 두부이걸다줘? = 도부이결다조!!!


## 88.반정규화(Denormalization)
- 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위
- 테이블 통합 : 두 개의 테이블이 조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
    - 검색은 간편하지만 레코드의 증가로 처리량이 증가
    - CUD 규칙이 복잡해질 수 있음
    - Not Null, Default, Check 등 제약조건을 설계하기 어려움
- 테이블 분할 : 테이블을 수평 또는 수직 분할
    - 수평 분할 : 레코드를 기준으로 분할, 레코드별 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 분할
    - 수직 분할 : 하나의 테이블에 속성이 너무 많을 결우 속성을 기준으로 테이블을 분할
        - 갱신 위주 : 갱신이 자주 일어나는 속성들을 수직 분할
        - 자주 조회 : 자주 조회되는 속성이 극히 일부 일때 분할
        - 크키가 큰 속성 : 이미지가 2GB이상 저장될 수 있는 텍스트 형식 등으로 괸 속성 분할
        - 보안 적용 : 테이블 내의 특정 속성에 대해 보안을 적용할 수 없으므로 보안을 적용해야 하는 속성을 분할
    - 기본키의 유일성 관리가 어려워짐
    - 수행 속도가 느려질 수 있음
    - 데이터 검색에 중점을 두어 테이블 분할 여부를 결정
- 중복 테이블 추가 : 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킬 수 있음
    - 정규화로 인해 수행 처리가 느려지는 경우
    - 많은 데이터를 자주 처리해야 하는 경우
    - 특정 범위의 데이터만 자주 처리해야 하는 경우
    - 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우
    - 방법
        - 집계 테이블 추가 : 집계 데이터를 위한 테이블 생성, 원본 테이블에 트리거를 설정
        - 진행 테이블 추가 : 이력 관리 등의 목적으로 추가하는 테이블, 기본키를 적절히 설정
        - 특정 부분만을 포함하는 테이블 추가 : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블 생성
- 중복 속성 추가 : 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것
    - 무결성 확보가 어렵고 디스크 공간이 추가로 필요
    - 중복 속성을 추가하는 경우
        - 조인이 자주 발생하는 속성인 경우
        - 접근 경로가 복잡한 속성인 경우
        - 액세스의 조건으로 자주 사용되는 경우
        - 기본키 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우
    - 고려사항
        - 테이블 중복과 속성의 중복을 고려
        - 데이터 일관성 및 무결성에 유의
        - SQL그룹함수를 이용하여 처리할 수 있어야함
        - 저장 공간의 지나친 낭비를 고려


## 89.시스템 카탈로그
- 시스템 카탈로그 : 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스(데이터 사전이라고도 함)
- 시스템 카탈로그 저장 정보 : 메타데이터(Meta-Data)라고 함
    - DB객체 정보 : 테이블, 인덱스. 뷰등의 구조 및 통계 정보
    - 사용자 정보 : 아이디, 패스워드, 접근 권한 등
    - 데이터 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등
    - 함수, 프로시저, 트리거 등에 대한 정보
- 특징
    - 일반 이용자도 SQL을 이용하여 내용을 검색할 수 있음
    - DDL문으로 카탈로그 갱신하는 것은 허용되지 않음
    - DBMS가 스스로 생성하고 유지
- 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템
    - DDL Compiler : DDL을 메다 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장
    - DML Compiler : 응용 프로그램에 삽입된 DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신
    - Data Directory : 데이터 사전에 수록된 데이터를 실제로 접근하는데 필요한 정보를 관리 유지하는 시스템, 시스템만 접근 가능
    - 질의 최적화기 : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략 모색
    - 트랜잭션 처리기 : 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각각의 사용자가 DB자원을 배타적으로 이용할 수 있도록 함