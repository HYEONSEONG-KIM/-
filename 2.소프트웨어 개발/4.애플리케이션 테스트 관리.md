# 애플리케이션 테스트 관리

## 53.애플리케이션 테스트
- 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차
    - Validation : 사용자 입장에서 요구사항에 맞게 구현 되었는지 확인
    - Verification : 개발자 입장에서 명세서에 맞게 만들었는지 확인
- 소프트웨어 분류
    - 상용 소프트웨어 : 보통의 사용자들이 공통적으로 필요로 하는 기능을 제공하는 소프트웨어
        - 산업 범용 소프트웨어 : 시스템 소프트웨어, 미들웨어, 응용 소프트웨어
        - 산업 특화 소프트웨어
    - 서비스 기능 제공 소프트웨어 : 신규 개발, 기능 개선, 추가 개발, 시스템 통합 소프트웨어
-  테스트의 필요성 
    - 프로그램 실행 전 오류 발견
    - 제품의 신뢰도 향상
    - 개발 초기부터 테스트 계획 -> 새로운 오류의 유입도 예방
    - 최소한의 시간과 노력으로 많은 결함 찾음
- 테스트의 기본 원리
    - 완벽한 테스팅 불가
    - 파레토 법칙(Pareto Principle) : 테스트로 발견된 80%의 오류는 20%의 모듈에서 발견, 그러므로 20%의 모듈을 집중적으로 테스트
    - 살충제 패러독스를 방지하기 위해 테스트 케이스를 지속적으로 보완 및 개선(Pesticide Paradox : 내성이 생겨 죽지 않음)
    - 테스트 정황에 따라 테스트를 다르게 수행
    - 사용자의 요구사항을 만족시키지 못하면 품질이 높다고 볼 수 없음(오류-부재의 궤변)
    - 테스트와 위험은 반비례
    - 작은 부분에서 점점 확대
    - 별도의 팀에서 수행


## 54.애플리케이션 테스트의 분류
- 프로그램 실행 여부에 따른 테스트
    - 정적 테스트 : 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트, 개발 비용 낮추는데 도움(워크스루, 인스펙션, 코드 검사등)
    - 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트, 개발의 모든 단계에서 테스트 수행 가능(블랙박스, 화이트 박스 테스트)
- 테스트 기반에 따른 테스트
    - 명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 테스트 케이스로 만듬(동등 분할, 경계 값 분석)
    - 구조 기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트를 작성(구문 기반, 결정 기반, 조건 기반)
    - 경험 기반 테스트 : 유사 소프트웨어나 기술 등에 따라 테스트의 경험을 기반으로 케이스를 작성(에러 추정, 체크리스트, 탐색적 테스팅 등)
- 시각에 따른 테스트
    - 검증 테스트 : 개발자의 시각에서 제품의 생산 과정을 테스트, 명세서대로 완성 되었는가 테스트
    - 확인 테스트 : 사용자의 시각에서 테스트
- 목적에 따른 테스트
    - 회복 테스트(Recovery) : 결함을 주어 복구 가능한지 테스트
    - 안전 테스트(Security) : 불법적인 침입으로부터 시스템을 보호할 수 있는가 테스트
    - 강도 테스트(Stress) : 과부하 시에도 정상실행 되는지 테스트
    - 성능 테스트(Performance) : 실시간 성능이나 전체적인 효율성을 진단하는 테스트
    - 구조 테스트(Structure) : 내부적인 경로, 소스코드의 복잡도를 평가하는 테스트
    - 회귀 테스트(Regression) : 변경 또는 수정 코드에 새로운 결함이 없는가 확인
    - 병행 테스트(Parallel) : 변경, 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교


## 55.테스트 기법에 따른 애플리케이션 테스트
- 화이트박스 테스트(White Box Test) : 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
    - 종류
        - 기초 경로 검사(Base Path Testing) : 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법, 결과는 실행 경로의 기초를 정의하는데 지침으로 사용
        - 제어 구조 검사(Control Stricture Testing) : 조건, 루프, 데이터 흐름검사
    - 검증 기준
        - 문자 검증 기중(Statement Coverage) : 소스 코드 구문이 한 번 이상 수행되도록 테스트 케이스 설계
        - 분기 검증 기준(Branch Coverage) : 소스 코드의 모든 조건문이 한 번 이상 수행되도록 테스트 케이스 설계
        - 조건 검증 기준(Condition Coverage) : 모든 조건문에 대해 true false인 경우가 한번 이상 수행 되도록하는 설계
        - 분기/조건 : 위의 두가지 병행
- 블랙박스 테스트(Black Box Test) : 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트
    - 사용자 요구사항 명세를 보면서 테스트, 주로 구현된 기능을 테스트
    - 인터페이스에서 실시되는 테스트
    - 테스트 과정 후반부에 사용
    - 종류
        - 동치 분할 검사(Equivalence Partitioning Testing) : 입력 자료에 초점, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법
        - 경계값 분석(Boundary Value Analysis) : 입력 조건의 중간값보다 경계값을 테스트로 선정하여 검사
        - 원인 효과 그래프 검사(Case Effect Graphing Testing) : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석, 효용성 높은 테스트 케이스 선정
        - 요류 예측 검사(Error Guessing) : 과거의 경험이나 확인자의 감각으로 테스트
        - 비교 검사(Comparison Testing) : 여러가지 프로그램에 동일한 테스트 자료를 제공, 동일한 결과가 출력되는지 테스트


## 56.개발 단계에 따른 애플리케이션 테스트
- 애플리케이션 테스트 : 소프트웨어의 개발 단계에 따라 단위, 통합, 시스템, 인수 테스트로 분류
    - 소프트웨어의 개발 단계에서부터 테스트 수행, 코드 뿐만 아니라 여러 오류를 발견할 수 있음
    - 요구사항 -> 분석 -> 설계 -> 구현 -> 단위 -> 통합 -> 시스템 -> 인수
- 단위 테스트(Unit Test) : 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점
    - 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
    - 구조 기반 테스트 시행 -> 화이트박스 테스트
- 통합 테스트(Intergration Test) : 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
- 시스템 테스트(System Test) : 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가 점검
    - 기능적 요구사항(블랙박스 테스트)과 비기능적 요구사항(화이트박스 테스트)으로 구분하여 각각 테스트
- 인수 테스트(Acceptance Test) : 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트
    - 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부 확인
    - 운영상 인수 테스트 : 시스템 관리자가 시스템 인수 시 수행
    - 계악 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부 확인
    - 규정 인수 테스트 : 정부 지침, 법규, 규정등에 맞게 개발되었는지 확인
    - 알파 테스트 : 개발된 장소에서 사용자가 개발자 앞에서 진행
    - 베타 테스트 : 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법


## 57.통합 테스트
- 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
    - 비점진적 통합 방식 : 단계적으로 통합하는 절차 없이 모든 모듈을 미리 결합되어 있는 프로그램 전체를 테스트
    - 점진적 통합 방식 : 모듈 단위로 단계적으로 통합하면서 테스트
- 하향식 통합 테스드(Top Down Itergration Test) : 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합
    - 깊이 우선 통합법 이나 넓이 우선 통합법 사용
    - 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
    - 상위 모듈에서는 사용하기 어려움
    - 종속모듈 스텁으로 대체 -> 하위모듈 스텁들 한 번에 하나씩 실제 모듈로 교체 -> 테스트 -> 회귀테스트 실시
- 상향식 통합 테스트(Bottom Up Intergration Test) : 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
    - 클러스터가 필요
    - 클러스터 결합 -> 드라이버 작성 -> 클러스터 단위로 테스트 -> 대체
- 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용, 샌드위치식 통합 테스트 방법
- 회귀 테스팅(Regression Test) : 이미 테스트된 프로그램의 테스팅을 반복, 테스트로 인해 변경된 모듈, 컴포넌트에 새로운 오류가 있는지 확인하는 테스트
    - 모든 테스트 케이스를 이용하면 좋지만 비용이 많이 드는 관계로, 변경된 부분을 테스트할 수 있는 케이스만 선정
    - 선정 방법
        - 모든 기능을 수행할 수 있는 대표적인 테스트 케이스 선정
        - 파급효과가 높은 부분이 포함된 테스트 케이스 선정
        - 실제 수정이 발생한 모듈 or 컴포넌트에서 시행하는 테스트 케이스 선정

## 58.애플리케이션 테스트 프로세스
- 개발된 소프트웨어가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차
    - 테스트 계획 -> 테스트 분석 및 디자인 -> 테스트 케이스 및 시나리오 작성 -> 테스트 수행 -> 테스트 결과 평가 및 리포팅 -> 결함 추적 및 관리
    - 테스트를 마치면 계획서, 테스트 케이스, 테스트 시나리오, 테스트 결과서 산출
- 테스트 계획 : 프로세스 계획서, 요구 명세서 등을 기반으로 테스트 목표를 정의하고 테스트 대상 및 범위를 결정
- 테스트 분석 및 디자인 : 테스트의 목적과 원칙을 검토, 사용자의 요구사항 분석
- 테스트 케이스 및 시나리오 분석 : 테스트 케이스의 설계 기법에 따라 테스트 케이스 작성, 검토 및 확인한 후 테스트 시나리오 작성
- 테스트 수행 : 테스트 환경을 구축한 후 테스트 수행
- 테스트 결과 평가 및 리포팅 : 테스트 결과를 비교 분석하여 테스트 결과서를 작성
- 결함 및 추적 관리 : 테스트를 수행한 후 결함이 어디에서 발생했는지, 어떤 종류의 결함인지 등 결함을 추적하고 관리


## 59.테스트 케이스/ 테스트 시나리오/ 테스트 오라클
- 테이스 케이스(Test Case) : 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서, 명세 기반 테스트의 설계 산출물에 해당
    - 작성 순서 : 테스트 계획 검토 및 자료 확보 -> 위험 평가 및 우선순위 결정 -> 테스트 요구사항 정의 -> 테스트 구조 설계 및 테스트 방법 결정 -> 테스트 케이스 정의 -> 테스트 케이스 타당성 확인 및 유지보수
- 테스트 시나리오(Test Scenario) : 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합, 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서
    - 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리하여 작성
    - 각각의 항목은 식별자 번호, 순서 번호, 테스트 데이터, 케이스, 예상 결과, 확인 등을 포함
- 테스트 오라클(Test Oracle) : 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법
    - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인
    - 제한된 검증 : 모든 테스트 케이스에 적용 불가
    - 수학적 기법 : 값을 수학적 기법을 이용하여 구할 수 있음
    - 자동화 가능 : 실행, 결과 비교 등을 자동화
    - 종류
        - 참(true) 오라클 : 모든 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클, 발생된 모든 오류 검출
        - 샘플링 오라클 : 특정한 몇몇 케이스의 입력 값들에 대해서만 결과 제공
        - 추정 오라클 : 샘플링 개선, 나머지 입력값들에 대해서도 추정으로 처리
        - 일관성 검사 오라클 : 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인    


## 60.테스트 자동화 도구
- 사람이 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것
    - 휴먼에러를 줄이고 테스트의 정확성을 유지하면서 품질을 향상
- 장단점
    - 장점 : 자동화함으로써 인력 및 시간을 줄임, 향상된 테스트 품질을 보장, 일관성있게 검증, 객관적인 평가제공, 다양한 표시 형태로 제공, 정밀 테스트 가능
    - 단점 : 도구에 대한 교육 및 학습 필요, 시간 비용 노력이 필요, 고가의 비용 추가 될 수 있음
- 고려사항
    - 재사용 및 측정이 불가능한 테스트 프로그램 제외
    - 적절한 도구 선택
    - 도구의 환경설정 및 습득 기간을 고려해서 프로젝트 일정 계획
    - 반드시 프로젝트 초기에 테스트 엔지니어 투입기를 계획
- 자동화 도구 유형
    - 정적 분석 도구 : 프로그램을 실행하지 않고 분석
    - 테스트 실행 도구 : 스트립트를 작성한 후 실행(스프레드 시트)
    - 성능 테스트 도구 : 가상의 사용자를 만들어 테스트
    - 테스트 통제 도구 : 테스트 계획 및 관리, 수행, 결함 등을 수행
    - 테스트 하네스 도구 : 테스트를 지원하기 위해 생성된 코드와 데이터
- 수행 단계별 테스트 자동화 도구
    - 계획 : 요구사항 관리
    - 테스트 분석/설계 : 테스트 케이스 생성,
    - 수행 : 테스트 자동화, 정적 분석, 동적 분석, 성능 테스트, 모니터링
    - 테스트 관리 : 커버리지 분석, 형상 관리, 결함 추적/관리


## 61.결함 관리
- 결함 : 오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작 하거나 다른 결과가 발생되는 것을 의미
- 결함 관리 프로세스 : 결함 관리 계획 -> 결함 기록(DB저장) -> 결함 검토 -> 결함 수정 -> 결함 재확인 -> 결함 상태 추적 및 모니터링 활동 -> 최종 결함 분석 및 보고서 작성
- 결함 상태 추적 : 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리
    - 결함 분포 : 결함 수 측정
    - 결함 추세 : 결함 수의 추이 분석
    - 결함 에이징 : 지속되는 시간 측정
- 결함 추석 순서 : 결함 등록 -> 검토 -> 할당 -> 수정 -> 조치 보류 -> 종료 -> 해제
- 결함 분류
    - 시스템 결함 : 애플리케이션 환경이나 데이터 베이스처리 에서 발생된 결함
    - 기능 결함 : 애플리케이션 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함
    - GUI 결함 : 사용자 화면 설계에서 발생된 결함
    - 문서 결함 : 기획자, 사용자, 개발자 간의 의사소통 및 기록이 원할하지 않아 발생된 결함
- 결함 심각도 : 애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도를 나타내는 척도(High - Medium - Low)
- 결함 우선순위 : 발견된 결함 처리에 대한 신속성을 나타내는 척도로, 결함의 중요도와 심각도에 따라 설정되고 수정 여부가 결정
    - 심각도가 높으면 우선순위도 높지만 반드시 그렇지는 않음
    - 결정적(Critical), 높음(High), 보통(Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등으로 분류


## 62.애플리케이션 성능 분석
- 애플리케이션 성능 : 사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
    - 처리량(Throughput) : 일정 시간 내에 어플이 처리하는 양
    - 응답시간(Response Time) : 요청을 전달항 시간 부터 도착할때 까지 걸린 시간
    - 경과시간(Turn Around Time) : 작업을 의뢰한 시간 부터 완료될 때까지 걸린 시간
    - 자원 사용률(Resource Usage) : 의뢰한 작업을 처리하는 동안의 자원사용률
- 성능 저하 원인 분석 : 성능 저하 현상은 애플리케이션을 DB에 연결하기 위해 Connection 객체를 생성하거나 쿼리를 실행하는 애플리케이션 로직에서 많이 발생
    - DB에 필요 이상의 많은 데이터를 요구한 경우
    - DB lock으로 인함 경우
    - Connection pool이 너무 크거나 작은 경우
    - 미들웨어를 사용한 후 종료 하지 않아 누수 발생
    - Commit 되지 않고 풀을 반환하거나, 잘못된 코드로 commit이 자주 발생하는 경우
    - 인터넷 접속 불량
    - 대량의 파일을 업 다운로드 하여 시간이 딜레이
    - 트랜잭션 처리 중 외부 호출이 장시간 수행 되거나 타임아웃
    - 네트워크 관련 장비 간 데이터 전송이 실패하거나 전송 지연으로 인해 데이터 손실 발생


## 63.복잡도
- 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말, 어느 정도 수준까지 테스트해야 하는지 또는 개발하는데 어느 정도의 자원이 소요되는지 예측하는데 사용
- 시간 복잡도 : 알고리즘 실행시간, 즉 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것
    - 빅오 표기법(Big-O Notation) : 실행시간이 최악일 때 표기하는 방법
        - O(1) : 입력값에 관계없이 일정하게 문제 해결에 하나의 단계만 거침(Push, Pop)
        - O(log n) : 문제 해결에 필요한 단계가 입력값 또는 조건에 의해 감소(이진트리, 이진검색)
        - O(n) : 입력값과 1:1의 관계 (for 문)
        - O(n log n) : n log n번 만큼 수행(병합정렬(merge sort), 힙 정렬(heap Sort))
        - O(n제곱): 입력값의 제곱만큼 수행(퀵정렬, 이중 for 문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort))
        - O(2의n제곱) : 2의 n제곱만큼 수행(피보나치 수열)
- 순환 복잡도 : 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도, 제어 흐름도 이론에 기초
    - V(G) = E - N + 2: E는 화살표 수, N은 노드의 수

## 64.애플리케이션 성능 개성
- 소스코드 최적화 : 나쁜코드를 배제하고 클린 코드로 작성하는 것
    - 클린 코드 : 잘 작성된 코드
        - 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
    - 나쁜 코드
        - 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀 있는 코드
        - 외계인 코드 : 아주 오래되거나 참고문서, 개발자가 없어 유지보수 작업이 어려운 코드
- 최적화 유형 : 클래스 분할 배치, 느슨한 결합, 코딩 형식 준수, 좋은 이름 사용, 적절한 주석문 사용
- 소스 코드 품질 분석 도구 : 소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구
    - 정적 분석 도구 : 작성한 소스 코드를 실행하지 않고 결함 확인(pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura등)
    - 동적 분석 도구 : 작성한 소스 코드를 실행(Avalanche, Valgrind등)















