# 애플리케이션 설계

## 21.소프트웨어 아키텍쳐
- 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
    + 상위 설계 : 아키택처 설계, 예비 설계(구조, DB, 인터페이스)
    + 하위 설계 : 모듈 설계, 상세 설계(컴포넌트, 자료 구조, 알고리즘)
- 모듈화(Modularity) : 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
- 추상화(Abstraction) : 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것(불필요한 부분 생략, 필요한 부분 강조)
- 단계적 분해(Stepwise Refinement) : Nikalus Wirth에 의해 제안된 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
- 정보 은닉(Information Hiding) : 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 소프트웨어 아키텍쳐의 품질 속성 : 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템, 비즈니스, 아기텍쳐 측면으로 구분하여 구체화시켜 놓은 것
- 설계 과정 : 설계 목표 설정 - 시스템 타입 결정 - 아키텍쳐 패턴 적용 - 서브시스템 구체화 - 검토
- 시스템 타입 : 일반적으로 대화형, 이벤트 중심, 변환형, 객체 영속형 시스템으로 나눔
- 협약에 의한 설계 : 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세
    + 선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조것
    + 결과 조건(Postcondotion) : 오퍼레이션이 수행된 후 만족되어야 할 조것
    + 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

## 22.아키텍쳐 패턴
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
    + 레이어 패턴(Layers Pattern) : 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나, OSI 참조 모델이 있음(물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층)
    + 클라이언트 - 서버 패턴(Client-Server Pattern) : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
    + 파이프 - 필터 패턴(Pipe-Filter Pattern) : 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 하여 파이프를 통해 데이터를 전송하는 패턴
    + 모델 - 뷰 - 컨트롤러 패턴(Model-View_controller Pattern) : 서브시스템을 3개의 부분으로 구조화 하는 패턴
        * 모델 - 서브시스템의 핵심 기능과 데이터를 보관
        * 뷰 - 사용자에게 정보를 표시
        * 컨트롤러 - 사용자로부터 받은 입력을 처리
    + 피어 - 투 - 피터 패턴(Peer-to-peer Pattern) : 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있음, 전형적인 멀티 스레딩 방식 사용

## 23.객체지향(Object-Orienred)
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립하여 작성할 수 있는 기법
    + 객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(갭슐화한) 하나의 소프트웨어 모듈
    + 클래스(Class) : 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미, 데이터를 추상화 하는 단위
    + 캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
    + 상속(Inhertiance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
    + 다형성(Polymorphism) : 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미
    + 연관성 : 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 의미
        * is member of - 연관화(Association) : 2개 이상의 객체가 상호 관련되어 있음을 의미
        * is instance of - 분류화(Classfiation) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
        * is part of - 집단화(Aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성 하는 것
        * is a - 일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
        * is a - 특수화/상세화(Specoaliztion) : 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 24.객체지향 분석 및 설계
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링 하는 작업
- 객제지향 분석의 방법론
    + Rumbaugh(럼바우) 방법 : 가장 일반적인 방법, 분석활동을 객체, 동적, 기능 모델로 나누어 수행
        * 객체 모델링 - 동적 모델링 - 기능 모델링 순서
    + Booch(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법, 클래스와 객체들을 분석 및 식별하고 클래스 속성과 연산을 정의
    + Jacobson 방법 : Use Case를 강조하여 사용하는 분석방법
    + Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체 모델링하며, 객체식별, 구조식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연걸 정의 등의 과정으로 구성하는 기법
    + Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법
- 객체지향 설계 원칙
    + 단일 책임 원칙(SRP) - 하나의 책임
    + 개방-폐쇄 원칙(OCP) - 캡슐화
    + 리스코프 치환 원칙(LSP) - 자식과 부모 클래스 간의 상속
    + 인터페이스 분리 원칙(ISP) - 인터페이스 분리
    + 의존 역전 원칙(DIP) - 의존 관계

## 25.모듈

- 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용
  - 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게

- 결합도(Coupling) : 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
  - 자료 결합도(Data Coupling) : 자료 요소로만 구성될 때의 결합도
  - 스탬프 결합도(Stamp Coupling) : 자료 구조가 전달될 때의 결합도
  - 제어 결합도(Control Coupling) : 흐름을 제어하기 위해 신호를 이용하여 통신하거나 제어요소를 전달하는 결합도
  - 외부 결합도(External Coupling) : 외부의 다른 모듈에서 참조할 때의 결합도
  - 공통(공유) 결합도(Common Coupling) : 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  - 내용 결합도(Content) : 내부 기능 및 자료를 직접 참조하거나 수정할 때의 결합도 

- 응집도(Cohesion) : 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
  - 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
  - 순차적 응집도(Sequential Cohesion) : 출력 되어 나온 데이터를 다음 활동의 입력 데이터로 사용할 경우의 응집도
  - 교환(통신)적 응집도(Conmmunication Cohesion) : 동일한 입출력 사용하여 서로 다른 기능을 수행하는 구성요소 들이 모였을때의 응집도
  - 절차적 응집도(Procedural Cohesion) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 순차적으로 수행
  - 시간적 응집도(Temporal Cohesion) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성
  - 논리적 응집도(Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성
  - 우연적 응집도(Coincidental Cohesion) : 서로 관련없는 요소로만 구성된 경우

- 팬인/팬아웃 
  - 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수
  - 팬 아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수
  - 복잡도를 최소화 하려면, 팬인은 높게 팬아웃은 낮게 설계

- N-S 차트 : 논리의 기술에 중점을 둔 도형을 이용한 표현 방법, 박스 다이어그램, Chapin Chart라고 함
  - 연속, 선택, 반복등의 제어 논리 구조를 표현
  - GOTO나 화살표 사용하지 않음
  - 조건의 복합화 되어 있는 곳의 처리를 시각적으로 명확히 식별
  - 총체적 구조표현과 인터페이스를 나타내기 어려움
  - 임의의 작성과 제어를 전이하는 것이 불가
  - 단일 입출구로 표현

  ## 26.공통 모듈

- 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미
- 다른 개발자 들이 해당 기능을 명확히 이해할 수 있도록 다음의 명세 기법 준수
  - 정확성(Correctness)
  - 명확성(Clarity)
  - 완전성(Completeness)
  - 일관성(Consistency)
  - 추적성(Traceability)

- 재사용 : 비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업
  - 함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용
  - 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
  - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용



## 27.코드

- 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호
  - 식별 기능 : 데이터 성격에 따라 구분 가능
  - 분류 기능 : 동일한 유형의 데이터 그룹화
  - 배열 기능 : 의미를 부여하여 나열
  - 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현
  - 간소화 기능 : 복잡한 데이터 간소화

- 코드의 종류
  - 순차 코드(Sequence Code) : 차례대로 일련번호 부여, 일련번호 코드
  - 블록 코드(Block Code) : 공통성이 있는 것끼리 블록으로 구분
  - 10진 코드(Demical Code) : 코드화 대상 10진 분할
  - 그룹 분류 코드(Group Classification Code) : 일정 기준에 따라 대분류, 중분류, 소분류로 구분
  - 연상 코드(Mnemonic Code) : 코드화 대상의 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드작성
  - 표의 숫자 코드(Significant Code) : 물리적 수치를 그대로 코드에 적용
  - 합성 코드(Combined Code) : 2개 이상의 코드를 조합

- 코드 부여 체계 : 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식



## 28.디자인 패턴

- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- GoF(Gang Of Four)의 디자인 패턴은 수많은 패턴 중 가장 일반적인 사례에 적용할 수 있는 패턴을을 분류하여 정리
- 생성 패턴(Creational Pattern) : 객체의 생성과 관련된 패턴으로 총 5개의 패턴
  - 추상 팩토리(Abstract Factory) : 서로 다른 부품을 조립
  - 빌더(Builder) : 건축가가 블록을 조립하는 모습
  - 팩토리 메소드(Factory Method) : 부품부터 완성품까지 통째로 찍어내는 공장, 가상생성자(Virtual Constructor)
  - 프로토타입(Prototype) : 원형을 두고 복제품을 만드는 것
  - 싱글톤(Singleton) : 하나뿐인 정수기

- 구조 패턴(Structural Pattern)
  - 어댑터(Adapter) : 전압을 맞춰주는 변압기
  - 브리지(Bridge) : 연결해주는 다리
  - 컴포지트(Composite) : 폴더와 파일을 합성
  - 데코레이터(Decorator) : 온갖 것으로 장식된 눈사람
  - 퍼싸드(Facade) : 외부의 리모컨 버튼만으로 간편하게 수행
  - 플라이 웨이트(Flyweight) : 부담을 가볍게 하기 위해 물품을 공유
  - 프록시(Proxy) : 어려운 업무 대리수행

-  행위 패턴(Behavioral Pattern)
  - 책임 연쇄(Chain of Responsbility) : 쏟아지는 물을 연속해서 받는 물레방아
  - 커맨드(Command) : 각종 명령어를 하나로 합쳐둔 것
  - 인터프리터(Interpreter) : 언어 번역가
  - 반복자(Iterator) : 같은 명령의 반복
  - 중재자(Mediator) : 물풀 매매를 중개해 주는 인터넷 사이트
  - 메멘토(Memento) : 기억 속의 그 때로 돌아가는 것
  - 옵서버(Observer) : 변화를 지켜보고 알려주는 것
  - 상태(State) : 상태에 따라 처방
  - 전략(Strategy) : 선택하여 쓰는 것
  - 템플릿 메서드(Templet Method) : 세모,네모등의 그리는 방법들을 도형이라는 하나의 큰 틀로 묶는 것
  - 방문자(Visitor) : 각 업무의 담당자들이 번갈아 방문