# 애플리케이션 설계

## 21.소프트웨어 아키텍쳐
- 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
    + 상위 설계 : 아키택처 설계, 예비 설계(구조, DB, 인터페이스)
    + 하위 설계 : 모듈 설계, 상세 설계(컴포넌트, 자료 구조, 알고리즘)
- 모듈화(Modularity) : 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
- 추상화(Abstraction) : 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것(불필요한 부분 생략, 필요한 부분 강조)
- 단계적 분해(Stepwise Refinement) : Nikalus Wirth에 의해 제안된 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
- 정보 은닉(Information Hiding) : 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 소프트웨어 아키텍쳐의 품질 속성 : 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템, 비즈니스, 아기텍쳐 측면으로 구분하여 구체화시켜 놓은 것
- 설계 과정 : 설계 목표 설정 - 시스템 타입 결정 - 아키텍쳐 패턴 적용 - 서브시스템 구체화 - 검토
- 시스템 타입 : 일반적으로 대화형, 이벤트 중심, 변환형, 객체 영속형 시스템으로 나눔
- 협약에 의한 설계 : 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세
    + 선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조것
    + 결과 조건(Postcondotion) : 오퍼레이션이 수행된 후 만족되어야 할 조것
    + 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

## 22.아키텍쳐 패턴
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
    + 레이어 패턴(Layers Pattern) : 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나, OSI 참조 모델이 있음(물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층)
    + 클라이언트 - 서버 패턴(Client-Server Pattern) : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
    + 파이프 - 필터 패턴(Pipe-Filter Pattern) : 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 하여 파이프를 통해 데이터를 전송하는 패턴
    + 모델 - 뷰 - 컨트롤러 패턴(Model-View_controller Pattern) : 서브시스템을 3개의 부분으로 구조화 하는 패턴
        * 모델 - 서브시스템의 핵심 기능과 데이터를 보관
        * 뷰 - 사용자에게 정보를 표시
        * 컨트롤러 - 사용자로부터 받은 입력을 처리
    + 피어 - 투 - 피터 패턴(Peer-to-peer Pattern) : 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있음, 전형적인 멀티 스레딩 방식 사용

## 23.객체지향(Object-Orienred)
- 현실 세계의 개체(Enitity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립하여 작성할 수 있는 기법
    + 객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(갭슐화한) 하나의 소프트웨어 모듈
    + 클래스(Class) : 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미, 데이터를 추상화 하는 단위
    + 캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
    + 상속(Inhertiance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
    + 다형성(Polymorphism) : 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미
    + 연관성 : 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 의미
        * is member of - 연관화(Association) : 2개 이상의 객체가 상호 관령되어 있음을 의미
        * is instance of - 분류화(Classfiation) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
        * is part of - 집단화(Aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성 하는 것
        * is a - 일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
        * is a - 특수화/상세화(Specoaliztion) : 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 24.객체지향 분석 및 설계
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링 하는 작업
- 객제지향 분석의 방법론
    + Rumbaugh(럼바우) 방법 : 가장 일반적인 방법, 분석활동을 객체, 동적, 기능 모델로 나누어 수행
        * 객체 모델링 - 동적 모델링 - 기능 모델링 순서
    + Booch(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법, 클래스와 객체들을 분석 및 식별하고 클래스 속성과 연산을 정의
    + Jacobson 방법 : Use Case를 강조하여 사용하는 분석방법
    + Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체 모델링하며, 객체식별, 구조식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연걸 정의 등의 과정으로 구성하는 기법
    + Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법
- 객체지향 설계 원칙
    + 단일 책임 원칙(SRP) - 하나의 책임
    + 개방-폐쇄 원칙(OCP) - 캡슐화
    + 리스코프 치환 원칙(LSP) - 자식과 부모 클래스 간의 상속
    + 인터페이스 분리 원칙(ISP) - 인터페이스 분리
    + 의존 역전 원칙(DIP) - 의존 관계

## 25.모듈

- 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용
  - 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게

- 결합도(Coupling) : 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
  - 자료 결합도(Data Coupling) : 자료 요소로만 구성될 때의 결합도
  - 스탬프 결합도(Stamp Coupling) : 자료 구조가 전달될 때의 결합도
  - 제어 결합도(Control Coupling) : 흐름을 제어하기 위해 신호를 이용하여 통신하거나 제어요소를 전달하는 결합도
  - 외부 결합도(External Coupling) : 외부의 다른 모듈에서 참조할 때의 결합도
  - 공통(공유) 결합도(Common Coupling) : 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  - 내용 결합도(Content) : 내부 기능 및 자료를 직접 참조하거나 수정할 때의 결합도 

- 응집도(Cohesion) : 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
  - 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
  - 순차적 응집도(Sequentia Cohesion) : 출력 되어 나온 데이터를 다음 활동의 입력 데이터로 사용할 경우의 응집도
  - 교환(통신)적 응집도(Conmmunication Cohesion) : 동일한 입출력 사용하여 서로 다른 기능을 수행하는 구성요소 들이 모였을때의 응집도
  - 절차적 응집도(Procedural Cohesion) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 순차적으로 수행
  - 시간적 응집도(Temporal Cohesion) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성
  - 논리적 응집도(Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성
  - 우연적 응집도(Coincidental Cohesion) : 서로 관련없는 요소로만 구성된 경우

- 팬인/팬아웃 
  - 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수
  - 팬 아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수
  - 복잡도를 최소화 하려면, 팬인은 높게 팬아웃은 낮게 설계

- N-S 차트 : 논리의 기술에 중점을 둔 도형을 이용한 표현 방법, 박스 다이어그램, Chapin Chart라고 함
  - 연속, 선택, 반복등의 제어 논리 구조를 표현
  - GOTO나 화살표 사용하지 않음
  - 조건의 복합화 되어 있는 곳의 처리를 시각적으로 명확히 식별
  - 총체적 구조표현과 인터페이스를 나타내기 어려움
  - 임의의 작성과 제어를 전이하는 것이 불가
  - 단일 입출구로 표현