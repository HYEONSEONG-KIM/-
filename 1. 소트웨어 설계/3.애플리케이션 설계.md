# 애플리케이션 설계

## 21.소프트웨어 아키텍쳐
- 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
    + 상위 설계 : 아키택처 설계, 예비 설계(구조, DB, 인터페이스)
    + 하위 설계 : 모듈 설계, 상세 설계(컴포넌트, 자료 구조, 알고리즘)
- 모듈화(Modularity) : 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
- 추상화(Abstraction) : 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것(불필요한 부분 생략, 필요한 부분 강조)
- 단계적 분해(Stepwise Refinement) : Nikalus Wirth에 의해 제안된 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
- 정보 은닉(Information Hiding) : 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 소프트웨어 아키텍쳐의 품질 속성 : 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템, 비즈니스, 아기텍쳐 측면으로 구분하여 구체화시켜 놓은 것
- 설계 과정 : 설계 목표 설정 - 시스템 타입 결정 - 아키텍쳐 패턴 적용 - 서브시스템 구체화 - 검토
- 시스템 타입 : 일반적으로 대화형, 이벤트 중심, 변환형, 객체 영속형 시스템으로 나눔
- 협약에 의한 설계 : 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세
    + 선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조것
    + 결과 조건(Postcondotion) : 오퍼레이션이 수행된 후 만족되어야 할 조것
    + 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

## 22.아키텍쳐 패턴
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
    + 레이어 패턴(Layers Pattern) : 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나, OSI 참조 모델이 있음(물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층)
    + 클라이언트 - 서버 패턴(Client-Server Pattern) : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
    + 파이프 - 필터 패턴(Pipe-Filter Pattern) : 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 하여 파이프를 통해 데이터를 전송하는 패턴
    + 모델 - 뷰 - 컨트롤러 패턴(Model-View_controller Pattern) : 서브시스템을 3개의 부분으로 구조화 하는 패턴
        * 모델 - 서브시스템의 핵심 기능과 데이터를 보관
        * 뷰 - 사용자에게 정보를 표시
        * 컨트롤러 - 사용자로부터 받은 입력을 처리
    + 피어 - 투 - 피터 패턴(Peer-to-peer Pattern) : 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있음, 전형적인 멀티 스레딩 방식 사용

## 23.객체지향(Object-Orienred)
- 현실 세계의 개체(Enitity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립하여 작성할 수 있는 기법
    + 객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(갭슐화한) 하나의 소프트웨어 모듈
    + 클래스(Class) : 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미, 데이터를 추상화 하는 단위
    + 캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
    + 상속(Inhertiance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
    + 다형성(Polymorphism) : 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미
    + 연관성 : 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 의미
        * is member of - 연관화(Association) : 2개 이상의 객체가 상호 관령되어 있음을 의미
        * is instance of - 분류화(Classfiation) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
        * is part of - 집단화(Aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성 하는 것
        * is a - 일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
        * is a - 특수화/상세화(Specoaliztion) : 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 24.객체지향 분석 및 설계
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링 하는 작업
- 객제지향 분석의 방법론
    + Rumbaugh(럼바우) 방법 : 가장 일반적인 방법, 분석활동을 객체, 동적, 기능 모델로 나누어 수행
        * 객체 모델링 - 동적 모델링 - 기능 모델링 순서
    + Booch(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법, 클래스와 객체들을 분석 및 식별하고 클래스 속성과 연산을 정의
    + Jacobson 방법 : Use Case를 강조하여 사용하는 분석방법
    + Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체 모델링하며, 객체식별, 구조식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연걸 정의 등의 과정으로 구성하는 기법
    + Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법
- 객체지향 설계 원칙
    + 단일 책임 원칙(SRP) - 하나의 책임
    + 개방-폐쇄 원칙(OCP) - 캡슐화
    + 리스코프 치환 원칙(LSP) - 자식과 부모 클래스 간의 상속
    + 인터페이스 분리 원칙(ISP) - 인터페이스 분리
    + 의존 역전 원칙(DIP) - 의존 관계
